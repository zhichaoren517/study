# 原型模式

1. 我们创建的每个函数都有一个 ***prototype(原型)属性*** , 这个属性是一个 ***指针*** ,指向一个 ***对象*** , 这个对象的用途是包含可以由特定类型的所有实例 ***共享的属性和方法*** . 按照字面意思理解 , prototype就是通过 ***调用构造函数创建的***那个对象实例的 ***原型对象*** .

2. 使用原型对象的好处是 , 让 ***所有对象实例共享它所包含的属性和方法*** .

<!------------------------------------------------------------------------------------------------------------->

## 理解原型
<!-- 
    function Person(){}
    Person.prototype.name = "jack"
    Person.prototype.age = 24 
    var person1 = new Person()
-->
* 
    ***constractor***

    无论什么时候,只要创建了一个新的函数,就会为该函数创建一个prototype属性 , 这个属性 ***指向函数的原型对象*** , 默认情况下,所有原型对象都会 ***自动获得一个constractor(构造函数)属性*** , 这个属性是 ***指向prototype属性所在函数的一个指针*** .
    例如: function Person(){} , Person.prototype.constructor指向Person .

* 
    ***__proto__***

    创建了自定义的构造函数之后 , 其 ***原型对象默认只会取得constractor属性*** . 其他的方法都是 ***从Object继承过来*** .
    当调用构造函数 ***创建一个新实例后*** , 该实例的内部将 ***包含一个指针(内部属性),指向构造函数的原型对象*** . ECMA-262第5版管这个指针叫做
    [[Prototype]] , 但在火狐 , 谷歌和safair在每个对象上都支持一个__proto__属性 , 而在其他的实现中 , 这个属性对脚本是不可见的 . 不过要明确一点 , ***这个连接存在于实例和构造函数的原型对象之间,而不是存在于实例和构造函数之间*** , 也就是说这个指针指向的是构造函数的prototype , 而不是构造函数 .

* 
    ***对象属性的读取***

    每当代码 ***读取某个对象的某个属性时*** , 都会 ***执行一次搜素*** , 目标是具有给定名字的属性 . 搜索先从对象对象实例本身开始 , 如果 ***找到*** 给定名字的属性 , 则 ***返回该属性的值*** ; 如果 ***没找到*** , 则 ***继续搜索指针指向的原型对象*** , 在 ***原型对象上找到*** 了这个属性 , 则 ***返回这个属性的值*** . 

* 
    ***原型属性的操作***

    虽然通过对象实例 ***可以访问*** 保存在 ***原型中的值*** , 但是却 ***不能通过对象实例改写*** 原型中的值 . 
    如果在实例中添加了 ***一个和实例原型中相同的属性***,该属性会 ***屏蔽掉原型中的同名属性*** . 这个属性只会 ***阻止我们访问原型中同名属性*** , 但***不会修改那个属性*** ,
    即使将这个属性的 ***值设为null***,也只会在实例中设置 , 而 ***不会恢复其指向原型的连接*** . 不过 ***使用delete操作符***可以完全 ***删除实例属性*** , 并且 ***能够重新访问原型中的属性***

<!------------------------------------------------------------------------------------------------------------->

## 原型in操作符

* in操作符的两种使用方式: 
    1. 单独使用:通过对象能够***访问到给定属性时返回true*** , ***无论该属性存在于实例还是原型中***; 用法: "name" in person1  
    2. for-in循环中使用:返回的事所有能通过对象访问的、可枚举的(enumerate)属性 , 其中既包括存在于实例重的属性 , 也包括存在于原型中的属性.
        屏蔽了原型中不可枚举的属性( enumberable属性为false )的实例属性也会返回 . 根据规定 , 所有开发人员定义的属性都是可枚举的

## 更简单的原型语法

* 
    为了避免每添加一个属性和方法就在就要敲一遍Person.prototype , 更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象
    例: function Person(){} 
        Person.prototype = {
            name:"jack",
            age:24,
            job:function(){ return "programmer" }
        }
    * 将Person.prototype设置为等于一个对象字面量形式创建的新对象 , 最终结果相同.

    * ***但是 , *onstructor属性不再指向Person了*** . 之前我们说过 , 每创建一个函数 , 就同时会创建他的prototype对象 , 这个对象会自动获得constructor属性 . 但是我们在这里使用的语法 , 本质上***完全重写了默认的prototype*** , 因此constructor属性也就变成了新对象的constructor属性( ***指向Object构造函数*** ) , 不再指向Person函数了.
    例: var p = new Person()
        p intanceof Object <!--true-->
        p intanceof Person <!--false-->
        p.constructor == Person <!--false-->
        p.constructor == Object <!--true-->

    * 如果constructor属性真的很重要 , 可以再55行插入 ***constructor : Person***来设置回适当的值 . 但是 , 这样设置会导致constuctor的[[enumerable]]特性被设置为true . 默认情况下 , 原生的constructor属性不可枚举
    
## 原型的动态性

* 由于在原型中查找值的过程是一次搜索 , 因此我们 ***读取原型对象所做的任何修改都能够立刻反映出来*** ---- ***即使是先创建了实例后修改原型*** . 
    其原因归结为***实例和原型之间的松散连接关系*** . 实例和原型之间的***连接只不过是一个指针 , 而非副本***.

* 虽然可以随时为原型添加属性和方法 , 并且修改能立刻在所有对象实例中反映出来 . 但如果是***重写整个原型对象(见55行) , 那么就不一样了 .***
    我们知道 , 调用构造函数时会为实例添加一个指向最初原型[[Prototype]]的指针 , 而把***原型修改为另一个对象就等于切断了构造函数和最初原型之间的联系*** . 请记住:***实例重的指针仅仅指向原型 , 而不指向构造函数***

## 原型对象的问题

* 它 ***省略了为构造函数传递初始化参数***这一环节 , 结果所有实例在 ***默认情况下都会取得相同的属性值*** . 但这还不是最大问题 . 最大的问题是由其 ***共享的本性*** 所导致的.

* 原型中所有属性是被很多实例共享的 , 这种共享对于函数非常合适 . 对于包含基本值的也说的过去 , 毕竟通过在实例上添加一个同名属性就可以隐藏原型中的对应属性 . 然而对于 ***包含引用类型值的属性*** 来说 , 问题几句比较突出 .
    例: function Person(){}
        Person.prototype = {
            constructor:Person,
            name:"jack",
            age:24,
            ***firend:[ "rose" ]***
        }
        var p1 = new Person()
        var p2 = new Person()
        console.log( p2.firend );<!--[ 'rose' ]-->
        console.log( p1.firend );<!--[ 'rose' ]-->
        ***p1.firend.push( "renzhch" )***
        console.log( p1.firend );<!--[ 'rose', 'renzhch' ]-->
        console.log( p2.firend );<!--[ 'rose', 'renzhch' ]-->



<!------------------------------------------------------------------------------------------------------------->

## Methods

* 
    ***isPrototypeOf( 实例 )***
    判断实例的__proto__是否指向构造函数的原型对象  ***isPrototypeOf(实例)***
    Person.prototype.isPrototypeOf( person1 )

* 
    ***Object.getPrototypeOf( 实例 )*** 
    ECMAScript增加了一个方法 ***Object.getPrototypeOf(实例)*** , 这个方法返回[[Prototype]]( __proto__ ) 的值
    Object.gePrototypeOf( person1 ) === Person.prototype  <!--true-->
    Object.gePrototypeOf( person1 ).name <!--jack-->

* 
    ***hasOwnProperty( property(属性) )***
    检测一个属性是否存在于实例中,还是存在于原型中 . ***属性存在与实例中 , 返回true*** , 否则返回false
    person1.hasOwnProperty( 'name' ) <!--true or false--> 

* 
    ***Object.keys(object)***
    接收一个对象作为参数,返回一个包含所有可枚举属性的字符串数组

* 
    ***Object.getOwnPropertyNames()***
    返回所有实例属性
    接收一个对象作为参数,返回一个包含所有属性的字符串数组,无论是否可枚举